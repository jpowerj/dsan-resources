{
  "hash": "81faec5064e0f455c0391e58c9789965",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Using LIWC for Document-Level Sentiment Analysis\"\nimage: images/liwc.jpg\nauthor: \"Jeff Jacobs\"\ninstitute: \"<a href='mailto:jj1088@georgetown.edu' target='_blank'>`jj1088@georgetown.edu`</a>\"\ndate: 2023-12-04\nformat:\n  html:\n    df-print: kable\ncategories:\n  - \"Text Analysis\"\n---\n\n\n## The Text Files\n\nYou can download the .txt files for positive and negative sentiment at the following links (click them to view the contents, or right click and choose \"Save Link As...\" to download)^[And, in case you want to use it in the future, you can download the entire set of word lists as a zip file <a href='assets/liwc.zip' target='_blank' class='pe-1'>here</a>]:\n\n* <a href='assets/liwc/031-posemo.txt' target='_blank'>`031-posemo.txt`</a>\n* <a href='assets/liwc/032-negemo.txt' target='_blank'>`032-negemo.txt`</a>\n\n## Converting Into Python Regular Expressions\n\nUsing them in this raw format is a bit tricky, however, since they are formatted not as individual words but as *regular expressions*, which will match entire *families* of positive and negative words. For example, `032-negemo.txt` contains the entry `troubl*`, which will therefore match the words `trouble`, `troubles`, `troubling`, and so on.\n\nSo, to work with these files in Python, we'll need to load the .txt files but then convert each entry into a **regular expression object**. This can be done using the following collection of functions:\n\n::: {#sentiment-on-strings .cell execution_count=1}\n``` {.python .cell-code}\nimport re\ndef load_liwc_list(filepath):\n    \"\"\"\n    :return: A list of words loaded from the file at `fpath`\n    \"\"\"\n    with open(filepath, 'r', encoding='utf-8') as infile:\n        words = infile.read().split()\n    return words\n\ndef liwc_to_regex(liwc_list):\n    \"\"\"\n    Converts LIWC expression list into Python regular expression\n    \"\"\"\n    wildcard_reg = [w.replace('*', r'[^\\s]*') for w in liwc_list]\n    reg_str = r'\\b(' + '|'.join(wildcard_reg) + r')\\b'\n    return reg_str\n\ndef num_matches(reg_str, test_str):\n    num_matches = len(re.findall(reg_str,test_str))\n    return num_matches\n\ndef file_to_regex(filepath):\n    liwc_list = load_liwc_list(filepath)\n    liwc_regex_list = liwc_to_regex(liwc_list)\n    return liwc_regex_list\n\n# You can call the following helper function if\n# you'd like to see the full regular expression\ndef print_regex(regex_str, wrap_col=70):\n    import textwrap\n    print(textwrap.fill(regex_str, wrap_col))\n```\n:::\n\n\nWe can use these functions to load the .txt files and create lists of regex (Regular Expression) objects from them:\n\n::: {#disp-regex .cell execution_count=2}\n``` {.python .cell-code}\npos_fpath = \"./assets/liwc/031-posemo.txt\"\npos_regex = file_to_regex(pos_fpath)\nneg_fpath = \"./assets/liwc/032-negemo.txt\"\nneg_regex = file_to_regex(neg_fpath)\n# Uncomment this line to see the full regular expression\n#print_regex(neg_regex)\nprint_regex(neg_regex[:140])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\\b(dismay[^\\s]*|ignorant|poorest|tragic|disreput[^\\s]*|ignore|poorly|t\nrauma[^\\s]*|abandon[^\\s]*|diss|ignored|poorness[^\\s]*|trembl[^\\s]*|abu\n```\n:::\n:::\n\n\n## Using the Regular Expressions to Generate Sentiment Scores\n\nAnd now we can use these generated regular expressions to count the number of times \"positive\" and \"negative\" words appear in our string! Here we provide two final helper functions for accomplishing this:\n\n::: {#count-pos-neg .cell execution_count=3}\n``` {.python .cell-code}\ndef extract_sentiment_data(text):\n    # First compute positive sentiment using pos_reg\n    pos_count = num_matches(pos_regex, text)\n    # Then negative sentiment using neg_reg\n    neg_count = num_matches(neg_regex, text)\n    # And finally the overall sentiment score as the difference\n    sentiment = pos_count - neg_count\n    return {\n        'pos': pos_count,\n        'neg': neg_count,\n        'sentiment': sentiment\n    }\n\ndef compute_sentiment(text):\n    full_results = extract_sentiment_data(text)\n    # Return just the overall sentiment score\n    return full_results['sentiment']\n```\n:::\n\n\nAnd here we test these helper functions out by creating positive, negative, and neutral *test strings* and checking the results for these strings:\n\n::: {#test-strings .cell execution_count=4}\n``` {.python .cell-code}\nneg_test_str = \"Python is terrible, I hate Python, I despise Python\"\nneg_str_results = extract_sentiment_data(neg_test_str)\nprint(f\"{neg_test_str}\\n{neg_str_results}\")\npos_test_str = \"Python is wonderful, I love Python, I adore Python\"\npos_str_results = extract_sentiment_data(pos_test_str)\nprint(f\"{pos_test_str}\\n{pos_str_results}\")\nneutral_test_str = \"Python is ok, Python is mid, I guess I can do Python maybe\"\nneutral_str_results = extract_sentiment_data(neutral_test_str)\nprint(f\"{neutral_test_str}\\n{neutral_str_results}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPython is terrible, I hate Python, I despise Python\n{'pos': 0, 'neg': 3, 'sentiment': -3}\nPython is wonderful, I love Python, I adore Python\n{'pos': 3, 'neg': 0, 'sentiment': 3}\nPython is ok, Python is mid, I guess I can do Python maybe\n{'pos': 1, 'neg': 0, 'sentiment': 1}\n```\n:::\n:::\n\n\n## Computing Sentiment Scores for a DataFrame Column\n\nEven though above we printed out the full results of each sentiment computation (by calling `extract_sentiment_data()`, which returns a dictionary containing the results), if you have a **DataFrame** with a text column that you'd like to perform sentiment analysis on, you can just use the simpler `compute_sentiment()` function to obtain a single number, like in the following code:\n\n::: {#cell-create-df .cell execution_count=5}\n``` {.python .cell-code}\nimport pandas as pd\ntext_df = pd.DataFrame({\n    'text_id': [1,2,3],\n    'text': [neg_test_str, pos_test_str, neutral_test_str]\n})\ntext_df\n```\n\n::: {#create-df .cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>text_id</th>\n      <th>text</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>Python is terrible, I hate Python, I despise P...</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>Python is wonderful, I love Python, I adore Py...</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>Python is ok, Python is mid, I guess I can do ...</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#cell-sentiment-on-df .cell execution_count=6}\n``` {.python .cell-code}\ntext_df['sentiment'] = text_df['text'].apply(compute_sentiment)\ntext_df\n```\n\n::: {#sentiment-on-df .cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>text_id</th>\n      <th>text</th>\n      <th>sentiment</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>Python is terrible, I hate Python, I despise P...</td>\n      <td>-3</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>Python is wonderful, I love Python, I adore Py...</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>Python is ok, Python is mid, I guess I can do ...</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}