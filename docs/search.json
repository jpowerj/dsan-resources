[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "A page with general resources for DSAN students, which I hope can be useful across multiple different DSAN courses!"
  },
  {
    "objectID": "posts/liwc/index.html",
    "href": "posts/liwc/index.html",
    "title": "Using LIWC for Document-Level Sentiment Analysis",
    "section": "",
    "text": "You can download the .txt files for positive and negative sentiment at the following links (click them to view the contents, or right click and choose “Save Link As…” to download)1:\n\n031-posemo.txt\n032-negemo.txt"
  },
  {
    "objectID": "posts/liwc/index.html#the-text-files",
    "href": "posts/liwc/index.html#the-text-files",
    "title": "Using LIWC for Document-Level Sentiment Analysis",
    "section": "",
    "text": "You can download the .txt files for positive and negative sentiment at the following links (click them to view the contents, or right click and choose “Save Link As…” to download)1:\n\n031-posemo.txt\n032-negemo.txt"
  },
  {
    "objectID": "posts/liwc/index.html#converting-into-python-regular-expressions",
    "href": "posts/liwc/index.html#converting-into-python-regular-expressions",
    "title": "Using LIWC for Document-Level Sentiment Analysis",
    "section": "Converting Into Python Regular Expressions",
    "text": "Converting Into Python Regular Expressions\nUsing them in this raw format is a bit tricky, however, since they are formatted not as individual words but as regular expressions, which will match entire families of positive and negative words. For example, 032-negemo.txt contains the entry troubl*, which will therefore match the words trouble, troubles, troubling, and so on.\nSo, to work with these files in Python, we’ll need to load the .txt files but then convert each entry into a regular expression object. This can be done using the following collection of functions:\n\nimport re\ndef load_liwc_list(filepath):\n    \"\"\"\n    :return: A list of words loaded from the file at `fpath`\n    \"\"\"\n    with open(filepath, 'r', encoding='utf-8') as infile:\n        words = infile.read().split()\n    return words\n\ndef liwc_to_regex(liwc_list):\n    \"\"\"\n    Converts LIWC expression list into Python regular expression\n    \"\"\"\n    wildcard_reg = [w.replace('*', r'[^\\s]*') for w in liwc_list]\n    reg_str = r'\\b(' + '|'.join(wildcard_reg) + r')\\b'\n    return reg_str\n\ndef num_matches(reg_str, test_str):\n    num_matches = len(re.findall(reg_str,test_str))\n    return num_matches\n\ndef file_to_regex(filepath):\n    liwc_list = load_liwc_list(filepath)\n    liwc_regex_list = liwc_to_regex(liwc_list)\n    return liwc_regex_list\n\n# You can call the following helper function if\n# you'd like to see the full regular expression\ndef print_regex(regex_str, wrap_col=70):\n    import textwrap\n    print(textwrap.fill(regex_str, wrap_col))\n\nWe can use these functions to load the .txt files and create lists of regex (Regular Expression) objects from them:\n\npos_fpath = \"./assets/liwc/031-posemo.txt\"\npos_regex = file_to_regex(pos_fpath)\nneg_fpath = \"./assets/liwc/032-negemo.txt\"\nneg_regex = file_to_regex(neg_fpath)\n# Uncomment this line to see the full regular expression\n#print_regex(neg_regex)\nprint_regex(neg_regex[:140])\n\n\\b(dismay[^\\s]*|ignorant|poorest|tragic|disreput[^\\s]*|ignore|poorly|t\nrauma[^\\s]*|abandon[^\\s]*|diss|ignored|poorness[^\\s]*|trembl[^\\s]*|abu"
  },
  {
    "objectID": "posts/liwc/index.html#using-the-regular-expressions-to-generate-sentiment-scores",
    "href": "posts/liwc/index.html#using-the-regular-expressions-to-generate-sentiment-scores",
    "title": "Using LIWC for Document-Level Sentiment Analysis",
    "section": "Using the Regular Expressions to Generate Sentiment Scores",
    "text": "Using the Regular Expressions to Generate Sentiment Scores\nAnd now we can use these generated regular expressions to count the number of times “positive” and “negative” words appear in our string! Here we provide two final helper functions for accomplishing this:\n\ndef extract_sentiment_data(text):\n    # First compute positive sentiment using pos_reg\n    pos_count = num_matches(pos_regex, text)\n    # Then negative sentiment using neg_reg\n    neg_count = num_matches(neg_regex, text)\n    # And finally the overall sentiment score as the difference\n    sentiment = pos_count - neg_count\n    return {\n        'pos': pos_count,\n        'neg': neg_count,\n        'sentiment': sentiment\n    }\n\ndef compute_sentiment(text):\n    full_results = extract_sentiment_data(text)\n    # Return just the overall sentiment score\n    return full_results['sentiment']\n\nAnd here we test these helper functions out by creating positive, negative, and neutral test strings and checking the results for these strings:\n\nneg_test_str = \"Python is terrible, I hate Python, I despise Python\"\nneg_str_results = extract_sentiment_data(neg_test_str)\nprint(f\"{neg_test_str}\\n{neg_str_results}\")\npos_test_str = \"Python is wonderful, I love Python, I adore Python\"\npos_str_results = extract_sentiment_data(pos_test_str)\nprint(f\"{pos_test_str}\\n{pos_str_results}\")\nneutral_test_str = \"Python is ok, Python is mid, I guess I can do Python maybe\"\nneutral_str_results = extract_sentiment_data(neutral_test_str)\nprint(f\"{neutral_test_str}\\n{neutral_str_results}\")\n\nPython is terrible, I hate Python, I despise Python\n{'pos': 0, 'neg': 3, 'sentiment': -3}\nPython is wonderful, I love Python, I adore Python\n{'pos': 3, 'neg': 0, 'sentiment': 3}\nPython is ok, Python is mid, I guess I can do Python maybe\n{'pos': 1, 'neg': 0, 'sentiment': 1}"
  },
  {
    "objectID": "posts/liwc/index.html#computing-sentiment-scores-for-a-dataframe-column",
    "href": "posts/liwc/index.html#computing-sentiment-scores-for-a-dataframe-column",
    "title": "Using LIWC for Document-Level Sentiment Analysis",
    "section": "Computing Sentiment Scores for a DataFrame Column",
    "text": "Computing Sentiment Scores for a DataFrame Column\nEven though above we printed out the full results of each sentiment computation (by calling extract_sentiment_data(), which returns a dictionary containing the results), if you have a DataFrame with a text column that you’d like to perform sentiment analysis on, you can just use the simpler compute_sentiment() function to obtain a single number, like in the following code:\n\nimport pandas as pd\ntext_df = pd.DataFrame({\n    'text_id': [1,2,3],\n    'text': [neg_test_str, pos_test_str, neutral_test_str]\n})\ntext_df\n\n\n\n\n\n\n\n\ntext_id\ntext\n\n\n\n\n0\n1\nPython is terrible, I hate Python, I despise P...\n\n\n1\n2\nPython is wonderful, I love Python, I adore Py...\n\n\n2\n3\nPython is ok, Python is mid, I guess I can do ...\n\n\n\n\n\n\n\n\ntext_df['sentiment'] = text_df['text'].apply(compute_sentiment)\ntext_df\n\n\n\n\n\n\n\n\ntext_id\ntext\nsentiment\n\n\n\n\n0\n1\nPython is terrible, I hate Python, I despise P...\n-3\n\n\n1\n2\nPython is wonderful, I love Python, I adore Py...\n3\n\n\n2\n3\nPython is ok, Python is mid, I guess I can do ...\n1"
  },
  {
    "objectID": "posts/liwc/index.html#footnotes",
    "href": "posts/liwc/index.html#footnotes",
    "title": "Using LIWC for Document-Level Sentiment Analysis",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nAnd, in case you want to use it in the future, you can download the entire set of word lists as a zip file here↩︎"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Resources for DSAN Students",
    "section": "",
    "text": "Using LIWC for Document-Level Sentiment Analysis\n\n\n\n\n\n\n\nText Analysis\n\n\n\n\n\n\n\n\n\n\n\nDec 4, 2023\n\n\nJeff Jacobs\n\n\n\n\n\n\nNo matching items"
  }
]